DROP TABLE IF EXISTS user_plaid_filters CASCADE;
CREATE TABLE user_plaid_filters (
  id int PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  user_id uuid NOT NULL REFERENCES public.users(id),
  filter text UNIQUE NOT NULL,
  category category NOT NULL
);

ALTER TABLE user_plaid_filters OWNER TO postgres;
ALTER TABLE user_plaid_filters ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own plaid filters" ON user_plaid_filters
  FOR SELECT
  TO authenticated
  USING ((SELECT auth.uid()) = user_id);

CREATE POLICY "Users can insert own plaid filters" ON user_plaid_filters
  FOR INSERT
  TO authenticated
  WITH CHECK ((SELECT auth.uid()) = user_id);

CREATE POLICY "Users can update own plaid filters" ON user_plaid_filters
  FOR UPDATE
  TO authenticated
  USING ((SELECT auth.uid()) = user_id);

CREATE POLICY "Users can delete own plaid filters" ON user_plaid_filters
  FOR DELETE
  TO authenticated
  USING ((SELECT auth.uid()) = user_id);


--
--
-- NEW
--
--

CREATE OR REPLACE FUNCTION update_transactions_for_new_global_plaid_filter()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE plaid_transactions
  SET category = NEW.category,
    user_filter_id = NULL,
    global_filter_id = NEW.id
  WHERE LOWER(name) LIKE '%' || LOWER(NEW.filter) || '%'
    AND category IS DISTINCT FROM NEW.category; -- Only update if category is different
  RETURN NULL;
END;
$$ LANGUAGE plpgsql SECURITY definer;

ALTER FUNCTION update_transactions_for_new_global_plaid_filter() OWNER TO postgres;

DROP TRIGGER IF EXISTS on_insert_global_plaid_filter ON global_plaid_filters;
CREATE TRIGGER on_insert_global_plaid_filter
  AFTER INSERT ON global_plaid_filters
    FOR EACH ROW
      EXECUTE FUNCTION update_transactions_for_new_global_plaid_filter();

-- When a global filter is deleted, update the category of all transactions that were using it
CREATE OR REPLACE FUNCTION update_transactions_for_deleted_global_plaid_filter()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE plaid_transactions
  SET category = CASE
    WHEN amount < 0 THEN 'Money-In'::category
    ELSE 'Money-Out'::category
  END
  WHERE global_filter_id = OLD.id;
  RETURN OLD;
END;
$$ LANGUAGE plpgsql;

ALTER FUNCTION update_transactions_for_deleted_global_plaid_filter() OWNER TO postgres;

DROP TRIGGER IF EXISTS on_delete_global_plaid_filter ON global_plaid_filters;
CREATE TRIGGER on_delete_global_plaid_filter
  BEFORE DELETE ON global_plaid_filters
    FOR EACH ROW
      EXECUTE FUNCTION update_transactions_for_deleted_global_plaid_filter();

CREATE OR REPLACE FUNCTION update_transactions_for_updated_global_plaid_filter()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE plaid_transactions
  SET category = NEW.category
  WHERE global_filter_id = NEW.id;
  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

ALTER FUNCTION update_transactions_for_updated_global_plaid_filter() OWNER TO postgres;

DROP TRIGGER IF EXISTS on_delete_global_plaid_filter ON global_plaid_filters;
CREATE TRIGGER on_delete_global_plaid_filter
  AFTER UPDATE ON global_plaid_filters
    FOR EACH ROW
      EXECUTE FUNCTION update_transactions_for_updated_global_plaid_filter();

-- Only allow the "category" column to be updated
CREATE OR REPLACE FUNCTION handle_update_global_plaid_filter()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.id <> OLD.id THEN
    RAISE EXCEPTION 'Updating "id" is not allowed';
  END IF;
  IF NEW.filter <> OLD.filter THEN
    RAISE EXCEPTION 'Updating "filter" is not allowed';
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

ALTER FUNCTION handle_update_global_plaid_filter() OWNER TO postgres;

DROP TRIGGER IF EXISTS on_update_global_plaid_filter ON global_plaid_filters;
CREATE TRIGGER on_update_global_plaid_filter
  BEFORE UPDATE ON global_plaid_filters
    FOR EACH ROW
      EXECUTE PROCEDURE handle_update_global_plaid_filter();

