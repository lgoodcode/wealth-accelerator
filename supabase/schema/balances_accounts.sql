CREATE TABLE balances_accounts (
  id int PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  user_id uuid REFERENCES public.users(id) ON DELETE CASCADE NOT NULL,
  name text NOT NULL
);

CREATE INDEX IF NOT EXISTS idx_balances_accounts_user_id ON balances_accounts(user_id);

ALTER TABLE balances_accounts OWNER TO postgres;
ALTER TABLE balances_accounts ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Can view own balance accounts" ON balances_accounts
  FOR SELECT
  TO authenticated
  USING ((SELECT auth.uid()) = user_id);

CREATE POLICY "Can insert new balance accounts" ON balances_accounts
  FOR INSERT
  TO authenticated
  WITH CHECK ((SELECT auth.uid()) = user_id);

CREATE POLICY "Can update own debt balance accounts" ON balances_accounts
  FOR UPDATE
  TO authenticated
  USING ((SELECT auth.uid()) = user_id)
  WITH CHECK ((SELECT auth.uid()) = user_id);

CREATE POLICY "Can delete own balance accounts" ON balances_accounts
  FOR DELETE
  TO authenticated
  USING ((SELECT auth.uid()) = user_id);



/**
 * Ensure that there are no duplicate account names for the same user
 */
CREATE OR REPLACE FUNCTION verify_balances_accounts()
RETURNS TRIGGER AS $$
DECLARE
  duplicate_count INT;
BEGIN
  SELECT COUNT(*) INTO duplicate_count
  FROM balances_accounts ba
  WHERE ba.user_id = NEW.user_id
    AND LOWER(ba.name) = LOWER(NEW.name)
    AND ba.id != NEW.id;

  IF duplicate_count > 0 THEN
    RAISE EXCEPTION 'Duplicate account name for the same user is not allowed';
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY definer;

ALTER FUNCTION verify_balances_accounts() OWNER TO postgres;

DROP TRIGGER IF EXISTS on_insert_or_update_balances_accounts ON balances_accounts;
CREATE TRIGGER on_insert_or_update_balances_accounts
  BEFORE INSERT OR UPDATE ON balances_accounts
    FOR EACH ROW
      EXECUTE FUNCTION verify_balances_accounts();
