DROP TABLE IF EXISTS clients CASCADE;
DROP TABLE IF EXISTS plaid CASCADE;
DROP TABLE IF EXISTS plaid_accounts CASCADE;
DROP TABLE IF EXISTS plaid_transactions CASCADE;
DROP TABLE IF EXISTS plaid_filters CASCADE;
DROP TABLE IF EXISTS debts CASCADE;
DROP TABLE IF EXISTS insurance_companies CASCADE;
DROP TABLE IF EXISTS insurance_policy CASCADE;
DROP TABLE IF EXISTS index_fund_rates CASCADE;
DROP TABLE IF EXISTS creative_cash_flow_inputs CASCADE;
DROP TABLE IF EXISTS creative_cash_flow_results CASCADE;

/**
 *  client table
 */
CREATE TABLE clients (
  id UUID NOT NULL PRIMARY KEY,
  role TEXT NOT NULL DEFAULT 'user',
  name TEXT NOT NULL,
  email TEXT UNIQUE NOT NULL,
  -- Timestamp needed so that the date is parsed correctly due to time zone
  start_date TIMESTAMP NOT NULL DEFAULT (CURRENT_DATE AT TIME ZONE 'PST'),
  stop_invest SMALLINT NOT NULL DEFAULT 10, -- both input
  start_withdraw SMALLINT NOT NULL DEFAULT 20, -- both input
  money_needed_to_live DECIMAL(10,2) NOT NULL DEFAULT 100000, -- both input
  tax_bracket DECIMAL(2,2) NOT NULL DEFAULT 0.35, -- both input (.35, .25)
  tax_bracket_future DECIMAL(2,2) NOT NULL DEFAULT 0.4,
  premium_deposit DECIMAL(10,2) NOT NULL DEFAULT 50000 -- both input
);

ALTER TABLE clients
  ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Can view own user data." ON clients
  FOR SELECT USING (auth.uid() = id);
CREATE POLICY "Can update own user data." ON clients
  FOR UPDATE USING (auth.uid() = id);

-- Function that creates a client entry when a new user is created
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.clients (id, email, name, role)
  VALUES (
    new.id,
    new.email,
    new.raw_user_meta_data->>'name',
    new.raw_user_meta_data->>'role'
  );
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY definer;

-- Trigger for when a new user is created, calls the function to create a client entry
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW
    EXECUTE FUNCTION public.handle_new_user();



/**
 *  plaid table
 */
CREATE TABLE plaid (
  item_id TEXT PRIMARY KEY,
  client_id UUID NOT NULL REFERENCES clients(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  access_token TEXT NOT NULL,
  expiration TIMESTAMP NOT NULL,
  -- Used for the /transactions/sync endpoint to get the latest transactions
  -- Can be null if the user has never synced their transactions, Plaid will start from the beginning
  cursor TEXT,
  -- Used to only require transactions sync once at most once every 8 hours
  last_synced TIMESTAMP
);

ALTER TABLE plaid
  ENABLE ROW LEVEL SECURITY;
CREATE POLICY "No access." ON plaid
  FOR SELECT USING (false);



/**
 *  plaid_accounts table
 */
CREATE TABLE plaid_accounts (
  account_id TEXT PRIMARY KEY,
  item_id TEXT NOT NULL REFERENCES plaid(item_id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  type TEXT NOT NULL, -- personal or business
  enabled BOOLEAN NOT NULL DEFAULT true
);

ALTER TABLE plaid_accounts
  ENABLE ROW LEVEL SECURITY;
CREATE POLICY "No access." ON plaid_accounts
  FOR SELECT USING (false);



/**
 *  plaid_transactions table
 */
DROP TYPE IF EXISTS CATEGORY;

CREATE TYPE CATEGORY AS ENUM ('Transfer', 'Money-In', 'Money-Out');

CREATE TABLE plaid_transactions (
  id TEXT PRIMARY KEY,
  item_id TEXT NOT NULL REFERENCES plaid(item_id) ON DELETE CASCADE,
  account_id TEXT NOT NULL REFERENCES plaid_accounts(account_id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  amount DECIMAL(10,2) NOT NULL,
  category CATEGORY NOT NULL,
  date DATE NOT NULL
);

ALTER TABLE plaid_transactions
  ENABLE ROW LEVEL SECURITY;
CREATE POLICY "No access." ON plaid_transactions
  FOR SELECT USING (false);



/**
 *  plaid_filters table
 */
CREATE TABLE plaid_filters (
  id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  filter TEXT NOT NULL,
  category CATEGORY NOT NULL
);

ALTER TABLE plaid_filters
  ENABLE ROW LEVEL SECURITY;
CREATE POLICY "No access." ON plaid_filters
  FOR SELECT USING (false);

-- Function that updates the transactions table with the category from the new or updated filter
CREATE OR REPLACE FUNCTION update_transaction_categories()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE plaid_transactions
  SET category = NEW.category
  WHERE name ILIKE '%' || NEW.filter || '%';
  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Trigger to update the transactions table when a new filter is created or updated
DROP TRIGGER IF EXISTS on_update_or_insert_filter_update_transaction_categories ON public.plaid_filters;
CREATE TRIGGER on_update_or_insert_filter_update_transaction_categories
AFTER INSERT OR UPDATE ON plaid_filters
  FOR EACH ROW
    EXECUTE FUNCTION update_transaction_categories();



/**
 *  debts table
 */
CREATE TABLE debts (
  id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  client_id UUID REFERENCES clients(id) ON DELETE CASCADE NOT NULL,
  description TEXT NOT NULL,
  amount_owed DECIMAL(10,2) NOT NULL,
  payment DECIMAL(7,2) NOT NULL,
  interest_rate DECIMAL(4,4) NOT NULL,
  months_remaining SMALLINT NOT NULL
);

ALTER TABLE debts
  ENABLE ROW LEVEL SECURITY;
CREATE POLICY "No access." ON debts
  FOR SELECT USING (false);



/**
 *  insurance_companies table
 */
CREATE TABLE insurance_companies (
  id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  name TEXT UNIQUE NOT NULL
);

ALTER TABLE insurance_companies
  ENABLE ROW LEVEL SECURITY;
CREATE POLICY "No access." ON insurance_companies
  FOR SELECT USING (false);



/**
 *  insurance_policy table
 */
CREATE TABLE insurance_policy (
  id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  client_id UUID REFERENCES clients(id) ON DELETE CASCADE NOT NULL,
  policy_id INT NOT NULL,
  name TEXT NOT NULL,
  company TEXT REFERENCES insurance_companies(name) NOT NULL,
  year SMALLINT NOT NULL,
  premium DECIMAL(10,2) NOT NULL DEFAULT 0,
  loan_interest_rate DECIMAL(4,4) NOT NULL DEFAULT 0.045,
  age_end_year SMALLINT NOT NULL,
  net_cash_value_end_year DECIMAL(10,2) NOT NULL,
  net_death_benefit_end_year DECIMAL(10,2) NOT NULL,
  annual_net_outlay DECIMAL(10,2) NOT NULL DEFAULT 0,
  cumulative_net_outlay DECIMAL(10,2) NOT NULL DEFAULT 0,
  net_annual_cash_value_increase DECIMAL(10,2) NOT NULL DEFAULT 0
);

ALTER TABLE insurance_policy
  ENABLE ROW LEVEL SECURITY;
CREATE POLICY "No access." ON insurance_policy
  FOR SELECT USING (false);



/**
 *  index_fund_rate table
 */
CREATE TABLE index_fund_rates ( -- both input
  id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  client_id UUID REFERENCES clients(id) ON DELETE CASCADE NOT NULL,
  year SMALLINT NOT NULL,
  rate DECIMAL(4,4) NOT NULL DEFAULT 0.07
);

ALTER TABLE index_fund_rates
  ENABLE ROW LEVEL SECURITY;
CREATE POLICY "No access." ON index_fund_rates
  FOR SELECT USING (false);

-- Function that creates the 60 rows for the index fund rates table for default values
-- The number of years is specified in the @/types/IndexFundRates.ts file
CREATE OR REPLACE FUNCTION public.handle_new_client_index_fund_rates()
RETURNS TRIGGER AS $$
BEGIN
  FOR i in 1..60 LOOP
    INSERT INTO public.index_fund_rates (client_id, year)
    VALUES (NEW.id, i);
  END LOOP;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY definer;

-- Trigger when a new client is created, calls the function to create the default values for
-- the index fund rates table
DROP TRIGGER IF EXISTS on_client_created_create_default_index_fund_rates_records ON public.clients;
CREATE TRIGGER on_client_created_create_default_index_fund_rates_records
  AFTER INSERT ON public.clients
  FOR EACH ROW
    EXECUTE FUNCTION public.handle_new_client_index_fund_rates();



/**
 *  creative_cash_flow_inputs table
 */
CREATE TABLE creative_cash_flow_inputs (
  id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  client_id UUID REFERENCES clients(id) ON DELETE CASCADE NOT NULL,
  created TIMESTAMP NOT NULL,
  start_date DATE NOT NULL,
  end_date DATE NOT NULL,
  all_other_income INT NOT NULL,
  payroll_and_distributions DECIMAL(10,2) NOT NULL,
  lifestyle_expenses_tax_rate DECIMAL(2,2) NOT NULL,
  tax_account_rate DECIMAL(2,2) NOT NULL,
  optimal_savings_strategies INT NOT NULL
);

  ALTER TABLE creative_cash_flow_inputs
    ENABLE ROW LEVEL SECURITY;
  CREATE POLICY "No access." ON creative_cash_flow_inputs
    FOR SELECT USING (false);



/**
 *  creative_cash_flow_results table
 */
CREATE TABLE creative_cash_flow_results (
  id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  client_id UUID REFERENCES clients(id) ON DELETE CASCADE NOT NULL,
  collections DECIMAL(10,2) NOT NULL,
  lifestyle_expenses DECIMAL(10,2) NOT NULL,
  lifestyle_expenses_tax DECIMAL(10,2) NOT NULL,
  business_checking_account_before_tax DECIMAL(10,2) NOT NULL,
  business_overhead DECIMAL(10,2) NOT NULL,
  tax_account DECIMAL(10,2) NOT NULL,
  waa_after_tax DECIMAL(10,2) NOT NULL,
  weekly_trend DECIMAL(10,2)[] NOT NULL,
  monthly_trend DECIMAL(10,2)[] NOT NULL,
  yearly_trend DECIMAL(10,2)[] NOT NULL,
  year_to_date DECIMAL(10,2) NOT NULL
);

ALTER TABLE creative_cash_flow_results
  ENABLE ROW LEVEL SECURITY;
CREATE POLICY "No access." ON creative_cash_flow_results
  FOR SELECT USING (false);





/**
 *
 *  FUNCTIONS
 *
 */

-- Deletes a user from both the clients auth.users tables
CREATE OR REPLACE FUNCTION public.delete_user(user_id UUID)
RETURNS VOID AS $$
BEGIN
  DELETE FROM clients WHERE id = user_id;
  DELETE FROM auth.users WHERE id = user_id;
END;
$$ LANGUAGE plpgsql SECURITY definer;



-- Retrieves basic user information to display for the /users/manage admin page
CREATE OR REPLACE FUNCTION public.get_users_display()
RETURNS TABLE(id UUID, name TEXT, email TEXT, role TEXT, policies SMALLINT, total_debt FLOAT) AS $$
BEGIN
  RETURN QUERY
  SELECT
    C.id,
    C.name,
    C.email,
    C.role,
    COUNT(DISTINCT I.policy_id)::SMALLINT,
    COALESCE(SUM(DISTINCT D.amount_owed), 0)::FLOAT
  FROM clients AS C
  LEFT JOIN insurance_policy AS I ON C.id = I.client_id
  LEFT JOIN debts AS D ON C.id = D.client_id
  GROUP BY C.id, C.name, C.role;
END;
$$ LANGUAGE plpgsql SECURITY definer;



-- Retrieves basic user information for a specific user for the /users/manage admin page
CREATE OR REPLACE FUNCTION public.get_user_display(user_id UUID)
RETURNS TABLE(id UUID, name TEXT, email TEXT, role TEXT, policies SMALLINT, total_debt FLOAT) AS $$
BEGIN
  RETURN QUERY
  SELECT
    C.id,
    C.name,
    C.email,
    C.role,
    COUNT(DISTINCT I.policy_id)::SMALLINT,
    COALESCE(SUM(DISTINCT D.amount_owed), 0)::FLOAT
  FROM clients AS C
  LEFT JOIN insurance_policy AS I ON I.client_id = user_id
  LEFT JOIN debts AS D ON D.client_id = user_id
  WHERE C.id = user_id
  GROUP BY C.id, C.name, C.role;
END;
$$ LANGUAGE plpgsql SECURITY definer;



-- Retrieves the last insurance policy id used to create a new policy
-- Used for the POST /api/policies route. Need to get the last policy id to create a new one
-- that is the last id value + 1. If no policies then -1 + 1 = 0 for first policy.
CREATE OR REPLACE FUNCTION public.get_user_last_policy_id(user_id UUID)
RETURNS INT AS $$
BEGIN
  RETURN (
    SELECT COALESCE(MAX(DISTINCT policy_id), -1)
    FROM insurance_policy
    WHERE client_id = user_id
  );
END;
$$ LANGUAGE plpgsql SECURITY definer;



-- Retrieves all accounts for all institutions for the user
CREATE OR REPLACE FUNCTION public.get_plaid_accounts(user_id UUID)
RETURNS JSON AS $$
BEGIN
  RETURN (
    SELECT json_agg(json_build_object(
      'account_id', pa.account_id,
      'item_id', pa.item_id,
      'name', pa.name,
      'type', pa.type
    )) AS accounts
    FROM plaid_accounts pa
    INNER JOIN plaid p ON pa.item_id = p.item_id
    WHERE p.client_id = user_id
  );
END;
$$ LANGUAGE plpgsql SECURITY definer;



-- Retrieves all transactions for all accounts for the user except for transactions
-- from accounts that are disabled
CREATE OR REPLACE FUNCTION public.get_transactions_by_account_ids(account_ids TEXT[])
RETURNS JSON AS $$
DECLARE
  personal_transactions JSON;
  business_transactions JSON;
BEGIN
  SELECT COALESCE(
    json_agg(
      json_build_object(
        'id', pt.id,
        'item_id', pt.item_id,
        'name', pt.name,
        'amount', pt.amount,
        'category', pt.category,
        'date', pt.date
      )
    ),
    '[]'::JSON
  ) INTO personal_transactions
  FROM plaid_transactions pt
    INNER JOIN plaid_accounts pa ON pt.account_id = pa.account_id
  WHERE
    pa.type = 'personal' AND
    pa.account_id = ANY(account_ids) AND
    pa.enabled = true;

  SELECT COALESCE(
    json_agg(
      json_build_object(
        'id', pt.id,
        'item_id', pt.item_id,
        'name', pt.name,
        'amount', pt.amount,
        'category', pt.category,
        'date', pt.date
      )
    ),
    '[]'::JSON
  ) INTO business_transactions
  FROM plaid_transactions pt
    INNER JOIN plaid_accounts pa ON pt.account_id = pa.account_id
  WHERE
    pa.type = 'business' AND
    pa.account_id = ANY(account_ids) AND
    pa.enabled = true;

  RETURN json_build_object(
    'personal', personal_transactions,
    'business', business_transactions
  );
END;
$$ LANGUAGE plpgsql SECURITY definer;
