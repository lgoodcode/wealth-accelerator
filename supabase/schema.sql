/**
 * users table
 *
 * This table is used to store user data that is not provided by Supabase Auth.
 * It is linked to the auth.users table via the id column.
 */

DROP TYPE IF EXISTS user_role CASCADE;
CREATE TYPE user_role AS enum ('USER', 'ADMIN');
ALTER TYPE user_role OWNER TO postgres;

DROP TABLE IF EXISTS public.users CASCADE;
CREATE TABLE users (
  id uuid PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  name text NOT NULL,
  role user_role NOT NULL DEFAULT 'USER'::user_role,
  email text UNIQUE NOT NULL,
  created_at timestamp with time zone NOT NULL DEFAULT timezone('utc'::text, now()),
  updated_at timestamp with time zone NOT NULL DEFAULT timezone('utc'::text, now())
);

ALTER TABLE public.users OWNER TO postgres;
ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;

CREATE OR REPLACE FUNCTION is_authenticated()
RETURNS BOOLEAN AS $$
BEGIN
  RETURN auth.uid() IS NOT NULL;
END;
$$ LANGUAGE plpgsql;

ALTER FUNCTION is_authenticated() OWNER TO postgres;

CREATE OR REPLACE FUNCTION is_admin(user_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
  PERFORM
  FROM public.users
  WHERE id = user_id AND role = 'ADMIN'::user_role;
  RETURN FOUND;
END;
$$ LANGUAGE plpgsql SECURITY definer;

ALTER FUNCTION is_admin(UUID) OWNER TO postgres;

CREATE OR REPLACE FUNCTION is_admin()
RETURNS BOOLEAN AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM public.users
    WHERE auth.uid() = id AND role = 'ADMIN'::user_role
  );
END;
$$ LANGUAGE plpgsql SECURITY definer;

ALTER FUNCTION is_admin() OWNER TO postgres;

CREATE POLICY "Can view their own data and admins can view all user data" ON public.users
  FOR SELECT
  TO authenticated
  USING (auth.uid() = id OR is_admin(auth.uid()));

CREATE POLICY "Can update own user data or admins can update all users data" ON public.users
  FOR UPDATE
  TO authenticated
  USING (auth.uid() = id OR is_admin(auth.uid()))
  -- WITH CHECK checks the data after modification, so we just check that the role is not changed if the user is not an admin
  WITH CHECK ((auth.uid() = id AND role = users.role) OR is_admin(auth.uid()));

CREATE POLICY "Admins can delete users" ON public.users
  FOR DELETE
  TO authenticated
  USING (is_admin(auth.uid()));

-- Function that creates a user in our users table when a new user is created in auth.users
CREATE OR REPLACE FUNCTION handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.users (id, email, name)
  VALUES (
    NEW.id,
    LOWER(NEW.email),
    INITCAP(NEW.raw_user_meta_data->>'name')
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY definer;

ALTER FUNCTION handle_new_user() OWNER TO postgres;

-- Trigger that calls the function above
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
    FOR EACH ROW
      EXECUTE PROCEDURE handle_new_user();





/**
 * peronal_finance table
 */

-- Function that generates the rates array of 60 numeric(5,2) [] with a default value of 7
-- and divide the value by 100 when displaying/using it
CREATE OR REPLACE FUNCTION generate_rates()
RETURNS numeric(5,2) [] AS $$
BEGIN
  RETURN ARRAY(SELECT 7::numeric(5,2) FROM generate_series(1, 60));
END
$$ LANGUAGE plpgsql SECURITY definer;

ALTER FUNCTION generate_rates() OWNER TO postgres;

DROP TABLE IF EXISTS personal_finance CASCADE;
CREATE TABLE personal_finance (
  id int PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  user_id uuid NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
  -- Strategy start date
  start_date timestamp with time zone NOT NULL DEFAULT timezone('utc'::text, now()),
  -- Index fund rates
  rates numeric(5,2) [] NOT NULL DEFAULT generate_rates(), -- generates an array of 60 numeric(5,2) [] with a default value of 7
  -- Wealth accelerator
  stop_invest smallint NOT NULL DEFAULT 10,
  start_withdrawl smallint NOT NULL DEFAULT 20,
  money_needed_to_live int NOT NULL DEFAULT 100000,
  tax_bracket smallint NOT NULL DEFAULT 25,
  tax_bracket_future smallint NOT NULL DEFAULT 30,
  premium_deposit int NOT NULL DEFAULT 50000,
  ytd_collections int NOT NULL DEFAULT 0,
  default_tax_rate smallint NOT NULL DEFAULT 25
);

ALTER TABLE personal_finance OWNER TO postgres;
ALTER TABLE personal_finance ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Can view own personal_finance data" ON public.personal_finance
  FOR SELECT
  TO authenticated
  USING (auth.uid() = user_id);

CREATE POLICY "Can update own personal_finance data" ON public.personal_finance
  FOR UPDATE
  TO authenticated
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- Function that creates a personal_finance row when a new user is created in public.users
CREATE OR REPLACE FUNCTION handle_init_personal_finance()
RETURNS TRIGGER AS $$
BEGIN
  -- Insert a new row into the personal_finance table for the new user
  INSERT INTO public.personal_finance (user_id) VALUES (NEW.id);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY definer;

ALTER FUNCTION handle_init_personal_finance() OWNER TO postgres;

-- Trigger the function above when a new user is created
DROP TRIGGER IF EXISTS on_user_created_init_personal_finance ON public.users;
CREATE TRIGGER on_user_created_init_personal_finance
  AFTER INSERT ON public.users
  FOR EACH ROW
    EXECUTE FUNCTION handle_init_personal_finance();





/**
 * debts table
 */

DROP TABLE IF EXISTS debts CASCADE;
CREATE TABLE debts (
  id int PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  user_id uuid REFERENCES public.users(id) ON DELETE CASCADE NOT NULL,
  description text NOT NULL,
  amount numeric(12,2) NOT NULL,
  payment numeric(12,2) NOT NULL,
  interest numeric(5,2) NOT NULL,
  months_remaining smallint NOT NULL DEFAULT 0
);

ALTER TABLE debts OWNER TO postgres;
ALTER TABLE debts ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Can view own debt data or admins can view all debt data" ON public.debts
  FOR SELECT
  TO authenticated
  USING (auth.uid() = user_id OR is_admin(auth.uid()));

CREATE POLICY "Can insert new debts" ON public.debts
  FOR INSERT
  TO authenticated
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Can update own debt data" ON public.debts
  FOR UPDATE
  TO authenticated
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Can delete own debts" ON public.debts
  FOR DELETE
  TO authenticated
  USING (auth.uid() = user_id);





/**
 * plaid table
 *
 * The main Plaid table containing the user's Plaid access tokens for each item.
 */

DROP TABLE IF EXISTS plaid CASCADE;
CREATE TABLE plaid (
  item_id text PRIMARY KEY,
  user_id uuid NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
  name text NOT NULL,
  access_token text UNIQUE NOT NULL,
  expiration timestamp with time zone NOT NULL,
  cursor text -- used to track last transactions synced
);

ALTER TABLE plaid OWNER TO postgres;
ALTER TABLE plaid ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Can view own institution data" ON public.plaid
  FOR SELECT
  TO authenticated
  USING (auth.uid() = user_id);

CREATE POLICY "Can insert new institutions" ON public.plaid
  FOR INSERT
  TO authenticated
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Can update own institution data" ON public.plaid
  FOR UPDATE
  TO authenticated
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Can delete own institutions" ON public.plaid
  FOR DELETE
  TO authenticated
  USING (auth.uid() = user_id);




/**
 * plaid_accounts table
 *
 * This table contains the user's accounts for each institution.
 */

DROP TYPE IF EXISTS account_type CASCADE;
CREATE TYPE account_type AS enum ('personal', 'business');
ALTER TYPE account_type OWNER TO postgres;

DROP TABLE IF EXISTS plaid_accounts CASCADE;
CREATE TABLE plaid_accounts (
  account_id text PRIMARY KEY,
  item_id text NOT NULL REFERENCES plaid(item_id) ON DELETE CASCADE,
  name text NOT NULL,
  type text NOT NULL DEFAULT 'business'::account_type,
  enabled boolean NOT NULL DEFAULT true
);

ALTER TABLE plaid_accounts OWNER TO postgres;
ALTER TABLE plaid_accounts ENABLE ROW LEVEL SECURITY;

-- Because the user_id is not stored in the plaid_accounts table, we need to join the plaid table
CREATE OR REPLACE FUNCTION is_own_plaid_account()
RETURNS BOOL AS $$
BEGIN
  PERFORM
  FROM plaid as p
  WHERE p.item_id = item_id AND p.user_id = auth.uid();
  RETURN FOUND;
END;
$$ LANGUAGE plpgsql SECURITY definer;

ALTER FUNCTION is_own_plaid_account() OWNER TO postgres;

CREATE POLICY "Can view own plaid accounts data" ON public.plaid_accounts
  FOR SELECT
  TO authenticated
  USING (is_own_plaid_account());

CREATE POLICY "Can insert own plaid accounts" ON public.plaid_accounts
  FOR INSERT
  TO authenticated
  WITH CHECK (is_own_plaid_account());

CREATE POLICY "Can update own plaid accounts data" ON public.plaid_accounts
  FOR UPDATE
  TO authenticated
  USING (is_own_plaid_account());

CREATE POLICY "Can delete own plaid accounts" ON public.plaid_accounts
  FOR DELETE
  TO authenticated
  USING (is_own_plaid_account());





/**
 * plaid_transactions table
 *
 * This table contains the user's transactions for each account.
 */

DROP TYPE IF EXISTS category CASCADE;
CREATE TYPE category AS ENUM ('Transfer', 'Money-In', 'Money-Out');
ALTER TYPE category OWNER TO postgres;

DROP TABLE IF EXISTS plaid_transactions CASCADE;
CREATE TABLE plaid_transactions (
  id text PRIMARY KEY, -- the transaction id from Plaid
  item_id text NOT NULL REFERENCES plaid(item_id) ON DELETE CASCADE,
  account_id text NOT NULL REFERENCES plaid_accounts(account_id) ON DELETE CASCADE,
  name text NOT NULL,
  amount numeric(12,2) NOT NULL,
  category category NOT NULL,
  date timestamp with time zone NOT NULL,
  user_filter_id int REFERENCES user_plaid_filters(id) ON DELETE SET NULL,
  global_filter_id int REFERENCES global_plaid_filters(id) ON DELETE SET NULL
);

ALTER TABLE plaid_transactions OWNER TO postgres;
ALTER TABLE plaid_transactions ENABLE ROW LEVEL SECURITY;

-- Because the user_id is not stored in the plaid_accounts table, we need to join the plaid table
CREATE OR REPLACE FUNCTION is_own_plaid_transaction()
RETURNS BOOL AS $$
BEGIN
  PERFORM
  FROM plaid as p
  WHERE p.item_id = item_id AND p.user_id = auth.uid();
  RETURN FOUND;
END;
$$ LANGUAGE plpgsql SECURITY definer;

ALTER FUNCTION is_own_plaid_transaction() OWNER TO postgres;

CREATE POLICY "Can view own plaid transactions data" ON public.plaid_transactions
  FOR SELECT
  TO authenticated
  USING (is_own_plaid_transaction());

CREATE POLICY "Can insert own plaid transactions" ON public.plaid_transactions
  FOR INSERT
  TO authenticated
  WITH CHECK (is_own_plaid_transaction());

CREATE POLICY "Can update own plaid transactions data" ON public.plaid_transactions
  FOR UPDATE
  TO authenticated
  USING (is_own_plaid_transaction());

CREATE POLICY "Can delete own plaid transactions" ON public.plaid_transactions
  FOR DELETE
  TO authenticated
  USING (is_own_plaid_transaction());

-- Function that formats a transaction that is being inserted
CREATE OR REPLACE FUNCTION format_transaction()
RETURNS TRIGGER AS $$
BEGIN
  NEW.date = NEW.date + INTERVAL '7 hours'; -- Add 7 hours to get it to proper UTC time format
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY definer;

ALTER FUNCTION format_transaction() OWNER TO postgres;

-- Trigger to format the transactions date whenever a new transaction is inserted
DROP TRIGGER IF EXISTS on_insert_plaid_transactions ON public.plaid_transactions;
CREATE TRIGGER on_insert_plaid_transactions
  BEFORE INSERT ON public.plaid_transactions
    FOR EACH ROW
      EXECUTE FUNCTION format_transaction();





/**
 * user_plaid_filters table
 */

DROP TABLE IF EXISTS user_plaid_filters CASCADE;
CREATE TABLE user_plaid_filters (
  id int PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  user_id uuid NOT NULL REFERENCES public.users(id),
  filter text UNIQUE NOT NULL,
  category category NOT NULL
);

ALTER TABLE user_plaid_filters OWNER TO postgres;
ALTER TABLE user_plaid_filters ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own plaid filters" ON user_plaid_filters
  FOR SELECT
  TO authenticated
  USING ((SELECT auth.uid()) = user_id);

CREATE POLICY "Users can insert own plaid filters" ON user_plaid_filters
  FOR INSERT
  TO authenticated
  WITH CHECK ((SELECT auth.uid()) = user_id);

CREATE POLICY "Users can update own plaid filters" ON user_plaid_filters
  FOR UPDATE
  TO authenticated
  USING ((SELECT auth.uid()) = user_id);

CREATE POLICY "Users can delete own plaid filters" ON user_plaid_filters
  FOR DELETE
  TO authenticated
  USING ((SELECT auth.uid()) = user_id);





/**
 * global_plaid_filters table
 */

DROP TABLE IF EXISTS global_plaid_filters CASCADE;
CREATE TABLE global_plaid_filters (
  id int PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  filter text UNIQUE NOT NULL,
  category category NOT NULL
);

ALTER TABLE global_plaid_filters OWNER TO postgres;
ALTER TABLE global_plaid_filters ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view global plaid filters" ON global_plaid_filters
  FOR SELECT
  TO authenticated
  USING ((SELECT is_authenticated()));

CREATE POLICY "Admins can insert global plaid filters" ON global_plaid_filters
  FOR INSERT
  TO authenticated
  WITH CHECK ((SELECT is_admin()));

CREATE POLICY "Admins can update global plaid filters" ON global_plaid_filters
  FOR UPDATE
  TO authenticated
  USING ((SELECT is_admin()));

CREATE POLICY "Admins can delete global plaid filters" ON global_plaid_filters
  FOR DELETE
  TO authenticated
  USING ((SELECT is_admin()));

CREATE OR REPLACE FUNCTION update_transactions_for_new_global_filter()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE plaid_transactions
  SET category = NEW.category,
    user_filter_id = NULL,
    global_filter_id = NEW.id
  WHERE LOWER(name) LIKE '%' || LOWER(NEW.filter) || '%'
    AND category IS DISTINCT FROM NEW.category; -- Only update if category is different
  RETURN NULL;
END;
$$ LANGUAGE plpgsql SECURITY definer;

ALTER FUNCTION update_transactions_for_new_global_filter() OWNER TO postgres;

DROP TRIGGER IF EXISTS on_insert_global_plaid_filter ON global_plaid_filters;
CREATE TRIGGER on_insert_global_plaid_filter
  AFTER INSERT ON global_plaid_filters
    FOR EACH ROW
      EXECUTE FUNCTION update_transactions_for_new_global_filter();





/**
 * creative_cash_flow table
 */

DROP TABLE IF EXISTS creative_cash_flow CASCADE;
CREATE TABLE creative_cash_flow (
  id uuid PRIMARY KEY NOT NULL,
  user_id uuid REFERENCES public.users(id) ON DELETE CASCADE NOT NULL
);

ALTER TABLE creative_cash_flow OWNER TO postgres;
ALTER TABLE creative_cash_flow ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Can view own CCF or if is admin" ON public.creative_cash_flow
  FOR SELECT
  TO authenticated
  USING (auth.uid() = user_id OR is_admin(auth.uid()));

CREATE POLICY "Can insert new CCF data" ON public.creative_cash_flow
  FOR INSERT
  TO authenticated
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Can update own CCF data" ON public.creative_cash_flow
  FOR UPDATE
  TO authenticated
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Can delete own CCF data" ON public.creative_cash_flow
  FOR DELETE
  TO authenticated
  USING (auth.uid() = user_id);

CREATE OR REPLACE function create_creative_cash_flow (
  _user_id uuid,
  _start_date timestamp with time zone,
  _end_date timestamp with time zone,
  _all_other_income numeric(12,2),
  _payroll_and_distributions numeric(12,2),
  _lifestyle_expenses_tax_rate numeric(5,2),
  _tax_account_rate numeric(5,2),
  _optimal_savings_strategy numeric(12,2),
  _collections numeric(12,2),
  _lifestyle_expenses numeric(12,2),
  _lifestyle_expenses_tax numeric(12,2),
  _business_profit_before_tax numeric(12,2),
  _business_overhead numeric(12,2),
  _tax_account numeric(12,2),
  _waa numeric(12,2),
  _total_waa numeric(12,2),
  _daily_trend numeric(12,2)[],
  _weekly_trend numeric(12,2)[],
  _yearly_trend numeric(12,2)[],
  _year_to_date numeric(12,2)
) RETURNS uuid as $$
DECLARE
  new_id uuid;
BEGIN
  -- Generate a new UUID using the uuid-ossp extension
  SELECT uuid_generate_v4() INTO new_id;

  INSERT INTO creative_cash_flow (id, user_id)
  VALUES (new_id, _user_id);

  INSERT INTO creative_cash_flow_inputs (id, user_id, start_date, end_date, all_other_income, payroll_and_distributions, lifestyle_expenses_tax_rate, tax_account_rate, optimal_savings_strategy)
  VALUES (new_id, _user_id, _start_date, _end_date, _all_other_income, _payroll_and_distributions, _lifestyle_expenses_tax_rate, _tax_account_rate, _optimal_savings_strategy);

  INSERT INTO creative_cash_flow_results (id, user_id, collections, lifestyle_expenses, lifestyle_expenses_tax, business_profit_before_tax, business_overhead, tax_account, waa, total_waa, daily_trend, weekly_trend, yearly_trend, year_to_date)
  VALUES (new_id, _user_id, _collections, _lifestyle_expenses, _lifestyle_expenses_tax, _business_profit_before_tax, _business_overhead, _tax_account, _waa, _total_waa, _daily_trend, _weekly_trend, _yearly_trend, _year_to_date);

  RETURN new_id;
END;
$$ LANGUAGE plpgsql SECURITY definer;

ALTER FUNCTION create_creative_cash_flow(
  _user_id uuid,
  _start_date timestamp with time zone,
  _end_date timestamp with time zone,
  _all_other_income numeric(12,2),
  _payroll_and_distributions numeric(12,2),
  _lifestyle_expenses_tax_rate numeric(5,2),
  _tax_account_rate numeric(5,2),
  _optimal_savings_strategy numeric(12,2),
  _collections numeric(12,2),
  _lifestyle_expenses numeric(12,2),
  _lifestyle_expenses_tax numeric(12,2),
  _business_profit_before_tax numeric(12,2),
  _business_overhead numeric(12,2),
  _tax_account numeric(12,2),
  _waa numeric(12,2),
  _total_waa numeric(12,2),
  _daily_trend numeric(12,2)[],
  _weekly_trend numeric(12,2)[],
  _yearly_trend numeric(12,2)[],
  _year_to_date numeric(12,2)
) OWNER TO postgres;




/**
 * creative_cash_flow_inputs table
 */

DROP TABLE IF EXISTS creative_cash_flow_inputs CASCADE;
CREATE TABLE creative_cash_flow_inputs (
  id uuid PRIMARY KEY NOT NULL REFERENCES creative_cash_flow(id) ON DELETE CASCADE,
  user_id uuid REFERENCES public.users(id) ON DELETE CASCADE NOT NULL,
  created_at timestamp with time zone NOT NULL DEFAULT timezone('utc'::text, now()),
  start_date timestamp with time zone NOT NULL,
  end_date timestamp with time zone NOT NULL,
  all_other_income numeric(12,2) NOT NULL,
  payroll_and_distributions numeric(12,2) NOT NULL,
  lifestyle_expenses_tax_rate numeric(5,2) NOT NULL,
  tax_account_rate numeric(5,2) NOT NULL,
  optimal_savings_strategy numeric(12,2) NOT NULL
);

ALTER TABLE creative_cash_flow_inputs OWNER TO postgres;
ALTER TABLE creative_cash_flow_inputs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Can view own CCF inputs data" ON public.creative_cash_flow_inputs
  FOR SELECT
  TO authenticated
  USING (auth.uid() = user_id);

CREATE POLICY "Can insert new CCF inputs" ON public.creative_cash_flow_inputs
  FOR INSERT
  TO authenticated
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Can delete own CCF inputs" ON public.creative_cash_flow_inputs
  FOR DELETE
  TO authenticated
  USING (auth.uid() = user_id);





/**
 * creative_cash_flow_results table
 */

DROP TABLE IF EXISTS creative_cash_flow_results CASCADE;
CREATE TABLE creative_cash_flow_results (
  id uuid PRIMARY KEY NOT NULL REFERENCES creative_cash_flow(id) ON DELETE CASCADE,
  user_id uuid REFERENCES public.users(id) ON DELETE CASCADE NOT NULL,
  collections numeric(12,2) NOT NULL,
  lifestyle_expenses numeric(12,2) NOT NULL,
  lifestyle_expenses_tax numeric(12,2) NOT NULL,
  business_profit_before_tax numeric(12,2) NOT NULL,
  business_overhead numeric(12,2) NOT NULL,
  tax_account numeric(12,2) NOT NULL,
  waa numeric(12,2) NOT NULL,
  total_waa numeric(12,2) NOT NULL,
  daily_trend numeric(12,2)[] NOT NULL,
  weekly_trend numeric(12,2)[] NOT NULL,
  yearly_trend numeric(12,2)[] NOT NULL,
  year_to_date numeric(12,2) NOT NULL
);

ALTER TABLE creative_cash_flow_results OWNER TO postgres;
ALTER TABLE creative_cash_flow_results ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Can view own CCF results data" ON public.creative_cash_flow_results
  FOR SELECT
  TO authenticated
  USING (auth.uid() = user_id);

CREATE POLICY "Can insert new CCF results" ON public.creative_cash_flow_results
  FOR INSERT
  TO authenticated
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Can delete own CCF results" ON public.creative_cash_flow_results
  FOR DELETE
  TO authenticated
  USING (auth.uid() = user_id);





/**
 * creative_cash_flow_notifiers table
 */

DROP TABLE IF EXISTS creative_cash_flow_notifiers CASCADE;
CREATE TABLE creative_cash_flow_notifiers (
  id int PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  name text NOT NULL,
  email text UNIQUE NOT NULL,
  enabled boolean NOT NULL DEFAULT true
);

ALTER TABLE creative_cash_flow_notifiers OWNER TO postgres;
ALTER TABLE creative_cash_flow_notifiers ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Admin can view plaid creative_cash_flow_notifiers data" ON public.creative_cash_flow_notifiers
  FOR SELECT
  TO authenticated
  USING (is_admin(auth.uid()));

CREATE POLICY "Admin can insert plaid creative_cash_flow_notifiers" ON public.creative_cash_flow_notifiers
  FOR INSERT
  TO authenticated
  WITH CHECK (is_admin(auth.uid()));

CREATE POLICY "Admin can update plaid creative_cash_flow_notifiers data" ON public.creative_cash_flow_notifiers
  FOR UPDATE
  TO authenticated
  USING (is_admin(auth.uid()));

CREATE POLICY "Admin can delete plaid creative_cash_flow_notifiers" ON public.creative_cash_flow_notifiers
  FOR DELETE
  TO authenticated
  USING (is_admin(auth.uid()));





/**
 * debt_snowball table
 */

DROP TYPE IF EXISTS debt_snowball_debt;
CREATE TYPE debt_snowball_debt AS (
  description text,
  amount numeric(12,2),
  payment numeric(12,2),
  interest numeric(5,2),
  months_remaining smallint
);
ALTER TYPE debt_snowball_debt OWNER TO postgres;

DROP TABLE IF EXISTS debt_snowball CASCADE;
CREATE TABLE debt_snowball (
  id uuid PRIMARY KEY NOT NULL,
  user_id uuid REFERENCES public.users(id) ON DELETE CASCADE NOT NULL,
  name text NOT NULL,
  debts debt_snowball_debt[] NOT NULL,
  created_at timestamp with time zone NOT NULL DEFAULT NOW()
);

ALTER TABLE debt_snowball OWNER TO postgres;
ALTER TABLE debt_snowball ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Can view own debt snowball data or if is admin" ON debt_snowball
  FOR SELECT
  TO authenticated
  USING ((SELECT auth.uid()) = user_id OR (SELECT is_admin()));

CREATE POLICY "Can insert new debt snowball data" ON debt_snowball
  FOR INSERT
  TO authenticated
  WITH CHECK ((SELECT auth.uid()) = user_id);

CREATE POLICY "Can update own debt snowball data" ON debt_snowball
  FOR UPDATE
  TO authenticated
  USING ((SELECT auth.uid()) = user_id)
  WITH CHECK ((SELECT auth.uid()) = user_id);

CREATE POLICY "Can delete own debt snowball data" ON debt_snowball
  FOR DELETE
  TO authenticated
  USING ((SELECT auth.uid()) = user_id);

-- Only allow the "name" column to be updated
CREATE OR REPLACE FUNCTION handle_update_debt_snowball()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.id <> OLD.id THEN
    RAISE EXCEPTION 'Updating "id" is not allowed';
  END IF;
  IF NEW.user_id <> OLD.user_id THEN
    RAISE EXCEPTION 'Updating "user_id" is not allowed';
  END IF;
  IF NEW.debts <> OLD.debts THEN
    RAISE EXCEPTION 'Updating "debts" is not allowed';
  END IF;
  IF NEW.created_at <> OLD.created_at THEN
    RAISE EXCEPTION 'Updating "created_at" is not allowed';
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

ALTER FUNCTION handle_update_debt_snowball() OWNER TO postgres;

DROP TRIGGER IF EXISTS on_update_debt_snowball ON debt_snowball;
CREATE TRIGGER on_update_debt_snowball
  BEFORE UPDATE ON debt_snowball
    FOR EACH ROW
      EXECUTE PROCEDURE handle_update_debt_snowball();





/**
 * debt_snowball_inputs table
 */

DROP TABLE IF EXISTS debt_snowball_inputs CASCADE;
CREATE TABLE debt_snowball_inputs (
  id uuid PRIMARY KEY NOT NULL REFERENCES debt_snowball(id) ON DELETE CASCADE,
  additional_payment numeric(12,2) NOT NULL,
  monthly_payment numeric(12,2) NOT NULL,
  opportunity_rate numeric(5,2) NOT NULL,
  strategy text NOT NULL,
  lump_amounts numeric(12,2)[] NOT NULL,
  pay_back_loan boolean NOT NULL,
  pay_interest boolean NOT NULL,
  loan_interest_rate numeric(5,2) NOT NULL
);

ALTER TABLE debt_snowball_inputs OWNER TO postgres;
ALTER TABLE debt_snowball_inputs ENABLE ROW LEVEL SECURITY;

CREATE OR REPLACE FUNCTION owns_debt_snowball_inputs_record()
RETURNS boolean AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM debt_snowball AS ds
    WHERE ds.id = id AND auth.uid() = ds.user_id
  );
END;
$$ language plpgsql;

ALTER FUNCTION owns_debt_snowball_inputs_record() OWNER TO postgres;

CREATE POLICY "Can view own debt snowball input data or if admin" ON public.debt_snowball_inputs
  FOR SELECT
  TO authenticated
  USING ((SELECT owns_debt_snowball_inputs_record()) OR (SELECT is_admin()));

CREATE POLICY "Can insert new debt snowball input data" ON public.debt_snowball_inputs
  FOR INSERT
  TO authenticated
  WITH CHECK ((SELECT owns_debt_snowball_inputs_record()));

CREATE POLICY "Can delete own debt snowball input data" ON public.debt_snowball_inputs
  FOR DELETE
  TO authenticated
  USING ((SELECT owns_debt_snowball_inputs_record()));





/**
 * debt_snowball_results types
 */

DROP TYPE IF EXISTS debt_snowball_debt_payoff_debt;
CREATE TYPE debt_snowball_debt_payoff_debt AS (
  description text
);
ALTER TYPE debt_snowball_debt_payoff_debt OWNER TO postgres;

DROP TYPE IF EXISTS debt_snowball_debt_payoff;
CREATE TYPE debt_snowball_debt_payoff AS (
  debt debt_snowball_debt_payoff_debt,
  payment_tracking numeric(12,2)[][]
);
ALTER TYPE debt_snowball_debt_payoff OWNER TO postgres;

DROP TYPE IF EXISTS current_calculation_results;
CREATE TYPE current_calculation_results AS (
  debt_payoffs debt_snowball_debt_payoff[],
  balance_tracking numeric(12,2)[][],
  interest_tracking numeric(12,2)[][],
  payoff_months integer,
  total_interest numeric(12,2),
  total_amount numeric(12,2)
);
ALTER TYPE current_calculation_results OWNER TO postgres;

DROP TYPE IF EXISTS loan_payback_type;
CREATE TYPE loan_payback_type AS (
  total numeric(12,2),
  interest numeric(12,2),
  months integer,
  tracking numeric(12,2)[][]
);
ALTER TYPE loan_payback_type OWNER TO postgres;

DROP TYPE IF EXISTS strategy_calculation_results;
CREATE TYPE strategy_calculation_results AS (
  debt_payoffs debt_snowball_debt_payoff[],
  balance_tracking numeric(12,2)[][],
  interest_tracking numeric(12,2)[][],
  payoff_months integer,
  total_interest numeric(12,2),
  total_amount numeric(12,2),
  snowball_tracking numeric(12,2)[][],
  loan_payback loan_payback_type
);
ALTER TYPE strategy_calculation_results OWNER TO postgres;



/**
 * debt_snowball_results table
 */

DROP TABLE IF EXISTS debt_snowball_results CASCADE;
CREATE TABLE debt_snowball_results (
  id uuid PRIMARY KEY NOT NULL REFERENCES debt_snowball(id) ON DELETE CASCADE,
  current current_calculation_results NOT NULL,
  strategy strategy_calculation_results NOT NULL
);

ALTER TABLE debt_snowball_results OWNER TO postgres;
ALTER TABLE debt_snowball_results ENABLE ROW LEVEL SECURITY;

CREATE OR REPLACE FUNCTION owns_debt_snowball_results_record()
RETURNS boolean AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM debt_snowball AS ds
    WHERE ds.id = id AND auth.uid() = ds.user_id
  );
END;
$$ language plpgsql;

ALTER FUNCTION owns_debt_snowball_results_record() OWNER TO postgres;

CREATE POLICY "Can view own debt snowball result data or if admin" ON debt_snowball_results
  FOR SELECT
  TO authenticated
  USING ((SELECT owns_debt_snowball_results_record()) OR (SELECT is_admin()));

CREATE POLICY "Can insert new debt snowball result data" ON debt_snowball_results
  FOR INSERT
  TO authenticated
  WITH CHECK ((SELECT owns_debt_snowball_results_record()));

CREATE POLICY "Can delete own debt snowball result data" ON debt_snowball_results
  FOR DELETE
  TO authenticated
  USING ((SELECT owns_debt_snowball_inputs_record()));





/**
 * debt_snowball function types
 */

DROP TYPE IF EXISTS debt_snowball_inputs_data;
CREATE TYPE debt_snowball_inputs_data AS (
  additional_payment numeric(12,2),
  monthly_payment numeric(12,2),
  opportunity_rate numeric(5,2),
  strategy text,
  lump_amounts numeric(12,2)[],
  pay_back_loan boolean,
  pay_interest boolean,
  loan_interest_rate numeric(5,2)
);
ALTER TYPE debt_snowball_inputs_data OWNER TO postgres;

DROP TYPE IF EXISTS debt_snowball_results_data;
CREATE TYPE debt_snowball_results_data AS (
  current current_calculation_results,
  strategy strategy_calculation_results
);
ALTER TYPE debt_snowball_results_data OWNER TO postgres;



/**
 * debt_snowball functions
 */

CREATE OR REPLACE FUNCTION create_debt_snowball_record (
  user_id uuid,
  name text,
  debts debt_snowball_debt[],
  inputs debt_snowball_inputs_data,
  results debt_snowball_results_data
) RETURNS TABLE (new_id uuid, new_created_at timestamp with time zone) AS $$
DECLARE
  new_id uuid;
  new_created_at timestamp with time zone;
BEGIN
  -- Generate a new UUID using the uuid-ossp extension
  SELECT uuid_generate_v4() INTO new_id;

  INSERT INTO debt_snowball (id, user_id, name, debts, created_at)
  VALUES (new_id, user_id, name, debts, NOW())
  RETURNING created_at INTO new_created_at;

  INSERT INTO debt_snowball_inputs (id, additional_payment, monthly_payment, opportunity_rate, strategy, lump_amounts, pay_back_loan, pay_interest, loan_interest_rate)
  VALUES (new_id, inputs.additional_payment, inputs.monthly_payment, inputs.opportunity_rate, inputs.strategy, inputs.lump_amounts, inputs.pay_back_loan, inputs.pay_interest, inputs.loan_interest_rate);

  INSERT INTO debt_snowball_results (id, current, strategy)
  VALUES (new_id, results.current, results.strategy);

  RETURN QUERY SELECT new_id, new_created_at;
END;
$$ LANGUAGE plpgsql;

ALTER FUNCTION create_debt_snowball_record(
  user_id uuid,
  name text,
  debts debt_snowball_debt[],
  inputs debt_snowball_inputs_data,
  results debt_snowball_results_data
) OWNER TO postgres;



-- When retrieving the data, on the client you will need to use the restoreLastArrayToLastZero
-- util function to restore the array to its original state for the following properties:
--     results.current.balance_tracking
--     results.strategy.balance_tracking
--     results.strategy.loan_payback.tracking
CREATE OR REPLACE FUNCTION get_debt_snowball_data_records(_user_id uuid)
RETURNS TABLE (
  id uuid,
  user_id uuid,
  name text,
  created_at timestamp with time zone,
  debts debt_snowball_debt[],
  inputs json, -- Using JSON because using a custom type this wasn't working
  results json
) AS $$
BEGIN
  RETURN QUERY
    SELECT
      ds.id,
      ds.user_id,
      ds.name,
      ds.created_at,
      ds.debts,
      json_build_object(
        'additional_payment', dsi.additional_payment,
        'monthly_payment', dsi.monthly_payment,
        'opportunity_rate', dsi.opportunity_rate,
        'strategy', dsi.strategy,
        'lump_amounts', dsi.lump_amounts,
        'pay_back_loan', dsi.pay_back_loan,
        'pay_interest', dsi.pay_interest,
        'loan_interest_rate', dsi.loan_interest_rate
      ) AS debt_snowball_inputs_data,
      json_build_object(
        'current', dsr.current,
        'strategy', dsr.strategy
      ) AS debt_snowball_results_data
  FROM debt_snowball ds
  JOIN debt_snowball_inputs dsi ON ds.id = dsi.id
  JOIN debt_snowball_results dsr ON ds.id = dsr.id
  WHERE ds.user_id = _user_id;
END;
$$ LANGUAGE plpgsql;

ALTER FUNCTION get_debt_snowball_data_records(_user_id uuid) OWNER TO postgres;



-- When retrieving the data, on the client you will need to use the restoreLastArrayToLastZero
-- util function to restore the array to its original state for the following properties:
--     results.current.balance_tracking
--     results.strategy.balance_tracking
--     results.strategy.loan_payback.tracking
CREATE OR REPLACE FUNCTION get_debt_snowball_data_record(record_id uuid)
RETURNS TABLE (
  id uuid,
  user_id uuid,
  name text,
  created_at timestamp with time zone,
  debts debt_snowball_debt[],
  inputs json, -- Using JSON because using a custom type this wasn't working
  results json
) AS $$
BEGIN
  RETURN QUERY
    SELECT
      ds.id,
      ds.user_id,
      ds.name,
      ds.created_at,
      ds.debts,
      json_build_object(
        'additional_payment', dsi.additional_payment,
        'monthly_payment', dsi.monthly_payment,
        'opportunity_rate', dsi.opportunity_rate,
        'strategy', dsi.strategy,
        'lump_amounts', dsi.lump_amounts,
        'pay_back_loan', dsi.pay_back_loan,
        'pay_interest', dsi.pay_interest,
        'loan_interest_rate', dsi.loan_interest_rate
      ) AS debt_snowball_inputs_data,
      json_build_object(
        'current', dsr.current,
        'strategy', dsr.strategy
      ) AS debt_snowball_results_data
  FROM debt_snowball ds
  JOIN debt_snowball_inputs dsi ON ds.id = dsi.id
  JOIN debt_snowball_results dsr ON ds.id = dsr.id
  WHERE ds.id = record_id;
END;
$$ LANGUAGE plpgsql;

ALTER FUNCTION get_debt_snowball_data_record(record_id uuid) OWNER TO postgres;



CREATE OR REPLACE FUNCTION delete_snowball_record(record_id UUID)
RETURNS VOID AS $$
BEGIN
  DELETE FROM debt_snowball WHERE id = record_id;
  DELETE FROM debt_snowball_results WHERE id = record_id;
  DELETE FROM debt_snowball_inputs WHERE id = record_id;
END;
$$ LANGUAGE plpgsql;

ALTER FUNCTION delete_snowball_record(record_id uuid) OWNER TO postgres;





-- /**
--  * insurance_companies table
--  */

-- DROP TABLE IF EXISTS insurance_companies CASCADE;
-- CREATE TABLE insurance_companies (
--   id int PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
--   name text UNIQUE NOT NULL
-- );

-- ALTER TABLE insurance_companies OWNER TO postgres;
-- ALTER TABLE insurance_companies ENABLE ROW LEVEL SECURITY;

-- CREATE POLICY "Admins can view data." ON public.insurance_companies
--   FOR SELECT
--   TO authenticated
--   USING (is_admin(auth.uid()));

-- CREATE POLICY "Admins can insert data." ON public.insurance_companies
--   FOR INSERT
--   TO authenticated
--   WITH CHECK (is_admin(auth.uid()));

-- CREATE POLICY "Admins can update data." ON public.insurance_companies
--   FOR UPDATE
--   TO authenticated
--   USING (is_admin(auth.uid()));

-- CREATE POLICY "Admins can delete data." ON public.insurance_companies
--   FOR DELETE
--   TO authenticated
--   USING (is_admin(auth.uid()));





-- /**
--  * insurance_policies table
--  */

-- DROP TABLE IF EXISTS insurance_policies CASCADE;
-- CREATE TABLE insurance_policies (
--   id int PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
--   user_id uuid REFERENCES public.users(id) ON DELETE CASCADE NOT NULL,
--   company_id int REFERENCES insurance_companies(id) NOT NULL,
--   name text NOT NULL
-- );

-- ALTER TABLE insurance_policies OWNER TO postgres;
-- ALTER TABLE insurance_policies ENABLE ROW LEVEL SECURITY;

-- CREATE POLICY "Admin can view insurance_policies data" ON public.insurance_policies
--   FOR SELECT
--   TO authenticated
--   USING (is_admin(auth.uid()));

-- CREATE POLICY "Admin can insert insurance_policies" ON public.insurance_policies
--   FOR INSERT
--   TO authenticated
--   WITH CHECK (is_admin(auth.uid()));

-- CREATE POLICY "Admin can update insurance_policies data" ON public.insurance_policies
--   FOR UPDATE
--   TO authenticated
--   USING (is_admin(auth.uid()));

-- CREATE POLICY "Admin can delete insurance_policies" ON public.insurance_policies
--   FOR DELETE
--   TO authenticated
--   USING (is_admin(auth.uid()));





-- /**
--  * insurance_policy_rows table
--  */

-- DROP TABLE IF EXISTS insurance_policy_rows CASCADE;
-- CREATE TABLE insurance_policy_rows (
--   id int PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
--   policy_id int REFERENCES insurance_policies(id) ON DELETE CASCADE NOT NULL,
--   year smallint NOT NULL,
--   premium int NOT NULL DEFAULT 0,
--   loan_interest_rate numeric(5,2) NOT NULL DEFAULT 45, -- divide by 100 -> 4.5%
--   age_end_year smallint NOT NULL,
--   net_cash_value_end_year int NOT NULL,
--   net_death_benefit_end_year int NOT NULL,
--   annual_net_outlay int NOT NULL DEFAULT 0,
--   cumulative_net_outlay int NOT NULL DEFAULT 0,
--   net_annual_cash_value_increase int NOT NULL DEFAULT 0
-- );

-- ALTER TABLE insurance_policy_rows OWNER TO postgres;
-- ALTER TABLE insurance_policy_rows ENABLE ROW LEVEL SECURITY;

-- CREATE POLICY "Admin can view insurance_policy_rows data" ON public.insurance_policy_rows
--   FOR SELECT
--   TO authenticated
--   USING (is_admin(auth.uid()));

-- CREATE POLICY "Admin can insert insurance_policy_rows" ON public.insurance_policy_rows
--   FOR INSERT
--   TO authenticated
--   WITH CHECK (is_admin(auth.uid()));

-- CREATE POLICY "Admin can update insurance_policy_rows data" ON public.insurance_policy_rows
--   FOR UPDATE
--   TO authenticated
--   USING (is_admin(auth.uid()));

-- CREATE POLICY "Admin can delete insurance_policy_rows" ON public.insurance_policy_rows
--   FOR DELETE
--   TO authenticated
--   USING (is_admin(auth.uid()));



-- /**
--  *
--  * Insurance Policy Functions
--  *
--  */

-- -- Retrieves the policies and combines the user and company for viewing in the policies page
-- CREATE OR REPLACE FUNCTION get_all_user_insurance_policy_views()
-- RETURNS SETOF jsonb
-- AS $$
-- BEGIN
--   RETURN QUERY
--   SELECT jsonb_build_object(
--     'user', jsonb_build_object(
--       'id', u.id,
--       'name', u.name
--     ),
--     'policy', jsonb_build_object(
--       'id', ip.id,
--       'name', ip.name
--     ),
--     'company', jsonb_build_object(
--       'id', ic.id,
--       'name', ic.name
--     )
--   )
--   FROM users AS u
--   INNER JOIN insurance_policies AS ip ON u.id = ip.user_id
--   INNER JOIN insurance_companies AS ic ON ip.company_id = ic.id
--   ORDER BY ip.id;
-- END;
-- $$ LANGUAGE plpgsql SECURITY definer;

-- ALTER FUNCTION get_all_user_insurance_policy_views() OWNER TO postgres;

-- -- Creates the new policy then, with the new policy id, inserts all the rows for that policy
-- CREATE OR REPLACE FUNCTION create_insurance_policy(
--   p_user_id uuid,
--   p_company_id int,
--   p_name text,
--   p_policy_rows insurance_policy_rows[] -- Array of insurance_policy_rows
-- ) RETURNS void AS $$
-- DECLARE
--   my_policy_id int;
--   p_row insurance_policy_rows;
--   default_premium numeric(12,2);
-- BEGIN
--   -- Get the premium_deposit value from the user's personal_finance table
--   SELECT premium_deposit INTO default_premium FROM personal_finance WHERE user_id = p_user_id;

--   -- Insert into insurance_policies table and get the generated id
--   INSERT INTO insurance_policies (user_id, company_id, name)
--   VALUES (p_user_id, p_company_id, p_name)
--   RETURNING id INTO my_policy_id;

--   -- Loop through the array and insert rows into insurance_policy_rows table
--   FOREACH p_row IN ARRAY p_policy_rows LOOP
--     INSERT INTO insurance_policy_rows (
--       policy_id,
--       year,
--       premium,
--       loan_interest_rate,
--       age_end_year,
--       net_cash_value_end_year,
--       net_death_benefit_end_year,
--       annual_net_outlay,
--       cumulative_net_outlay,
--       net_annual_cash_value_increase
--     )
--     VALUES (
--       my_policy_id,
--       p_row.year,
--       COALESCE(p_row.premium, default_premium),
--       COALESCE(p_row.loan_interest_rate, 45), -- Use default value of 45 if p_row.loan_interest_rate is null
--       p_row.age_end_year,
--       p_row.net_cash_value_end_year,
--       p_row.net_death_benefit_end_year,
--       p_row.annual_net_outlay,
--       p_row.cumulative_net_outlay,
--       p_row.net_annual_cash_value_increase
--     );
--   END LOOP;
-- END;
-- $$ LANGUAGE plpgsql SECURITY definer;

-- ALTER FUNCTION create_insurance_policy(p_user_id uuid, p_company_id int, p_name text, p_policy_rows insurance_policy_rows[]) OWNER TO postgres;




/**
 *
 *  FUNCTIONS
 *
 */

-- Used to check if an email is used when inviting users in the Manager Users section
CREATE OR REPLACE FUNCTION is_email_used(email text)
RETURNS BOOLEAN AS $$
BEGIN
  RETURN EXISTS (SELECT 1 FROM auth.users as a WHERE a.email = $1);
END;
$$ LANGUAGE plpgsql SECURITY definer;

ALTER FUNCTION is_email_used(email text) OWNER TO postgres;



CREATE OR REPLACE FUNCTION get_transactions_with_account_name(ins_item_id text, offset_val int, limit_val int)
RETURNS TABLE (
    id text,
    item_id text,
    account_id text,
    name text,
    amount numeric(12,2),
    category category,
    date timestamp with time zone,
    account text
) AS $$
BEGIN
    RETURN QUERY
        SELECT
            t.id,
            t.item_id,
            t.account_id,
            t.name,
            t.amount,
            t.category,
            t.date,
            a.name AS account
        FROM
            plaid_transactions t
        INNER JOIN
            plaid_accounts a ON t.account_id = a.account_id
        WHERE
            t.item_id = ins_item_id AND a.enabled = true
        ORDER BY
            t.date DESC
        OFFSET
            offset_val
        LIMIT
            limit_val;
END;
$$ LANGUAGE plpgsql SECURITY definer;

ALTER FUNCTION get_transactions_with_account_name(ins_item_id text, offset_val int, limit_val int) OWNER TO postgres;


-- Retrieves all transactions for all accounts for the user except for transactions
-- from accounts that are disabled and returns them in a JSON object with the
-- following structure:
-- {
--   "personal": Transaction[],
--   "business": Transaction[]
-- }
CREATE OR REPLACE FUNCTION get_transactions_by_user_id(user_id uuid)
RETURNS JSON AS $$
DECLARE
  personal_transactions JSON;
  business_transactions JSON;
BEGIN
  SELECT COALESCE(
    json_agg(
      json_build_object(
        'id', pt.id,
        'item_id', pt.item_id,
        'name', pt.name,
        'amount', pt.amount,
        'category', pt.category,
        'date', pt.date
      )
    ),
    '[]'::JSON
  ) INTO personal_transactions
  FROM plaid_transactions pt
    INNER JOIN plaid_accounts pa ON pt.account_id = pa.account_id
    INNER JOIN plaid p ON p.item_id = pa.item_id
    INNER JOIN users u ON u.id = p.user_id
  WHERE
    pa.type = 'personal' AND
    u.id = $1 AND
    pa.enabled = true;

  SELECT COALESCE(
    json_agg(
      json_build_object(
        'id', pt.id,
        'item_id', pt.item_id,
        'name', pt.name,
        'amount', pt.amount,
        'category', pt.category,
        'date', pt.date
      )
    ),
    '[]'::JSON
  ) INTO business_transactions
  FROM plaid_transactions pt
    INNER JOIN plaid_accounts pa ON pt.account_id = pa.account_id
    INNER JOIN plaid p ON p.item_id = pa.item_id
    INNER JOIN users u ON u.id = p.user_id
  WHERE
    pa.type = 'business' AND
    u.id = $1 AND
    pa.enabled = true;

  RETURN json_build_object(
    'personal', personal_transactions,
    'business', business_transactions
  );
END;
$$ LANGUAGE plpgsql SECURITY definer;

ALTER FUNCTION public.get_transactions_by_user_id(user_id uuid) OWNER TO postgres;



-- Function that retrieves the user's creative cash flow records by return a JSON object
-- with the following structure:
-- {
--   "id": int,
--   "inputs": CreativeCashFlowInputs[],
--   "results": CreativeCashFlowResults[]
-- }
-- and is sorted by the created date in descending order
CREATE OR REPLACE FUNCTION get_creative_cash_flow_records(arg_user_id uuid)
RETURNS TABLE (id uuid, inputs jsonb, results jsonb) AS $$
BEGIN
    RETURN QUERY
        SELECT
            cc.id,
            to_jsonb(ccfi.*) AS ccfi,
            to_jsonb(ccfr.*) AS ccfr
        FROM creative_cash_flow cc
        JOIN creative_cash_flow_inputs ccfi ON cc.id = ccfi.id
        JOIN creative_cash_flow_results ccfr ON cc.id = ccfr.id
        WHERE ccfi.user_id = arg_user_id
        ORDER BY ccfi.created_at DESC;
END;
$$ LANGUAGE plpgsql SECURITY definer;

ALTER FUNCTION get_creative_cash_flow_records(arg_user_id uuid) OWNER TO postgres;



-- Function that retrieves s specific creative cash flow record in a JSON object
-- with the following structure:
-- {
--   "id": uuid,
--   "inputs": CreativeCashFlowInputs,
--   "results": CreativeCashFlowResults
-- }
CREATE OR REPLACE FUNCTION get_creative_cash_flow_record(record_id uuid)
RETURNS TABLE (id uuid, inputs jsonb, results jsonb) AS $$
BEGIN
    RETURN QUERY
        SELECT
            cc.id,
            to_jsonb(ccfi.*) AS inputs,
            to_jsonb(ccfr.*) AS results
        FROM creative_cash_flow cc
        JOIN creative_cash_flow_inputs ccfi ON cc.id = inputs.id
        JOIN creative_cash_flow_results ccfr ON cc.id = results.id
        WHERE cc.id = record_id;
END;
$$ LANGUAGE plpgsql SECURITY definer;

ALTER FUNCTION get_creative_cash_flow_record(record_id uuid) OWNER TO postgres;



-- Gets the running total of the user's WAA before the start date of the range used when
-- calculating the CCF
CREATE OR REPLACE FUNCTION total_waa_before_date(user_id uuid, target_date timestamp with time zone)
RETURNS NUMERIC AS $$
DECLARE
  total_waa_sum numeric;
BEGIN
  SELECT COALESCE(SUM(cfr.waa), 0)
  INTO total_waa_sum
  FROM creative_cash_flow_results cfr
  JOIN creative_cash_flow_inputs cci ON cfr.id = cci.id
  WHERE cfr.user_id = $1 AND cci.end_date <= target_date;

  RETURN total_waa_sum;
END;
$$ LANGUAGE plpgsql SECURITY definer;

ALTER FUNCTION total_waa_before_date(user_id uuid, target_date timestamp with time zone) OWNER TO postgres;



-- Updates a user's profile by first checking if the provided email is already in use and if it
-- is then it throws an exception. If it isn't then it updates the user's email and name. In
-- both the auth.users and public.users tables for emails and name in public.users.
CREATE OR REPLACE function update_user_profile(new_name text, new_email text)
RETURNS JSON AS $$
DECLARE
  user_id uuid;
BEGIN
  user_id := auth.uid();

  -- Check if the email is already in use
  IF EXISTS (SELECT 1 FROM auth.users WHERE email = new_email AND id != user_id) THEN
    RAISE EXCEPTION 'Email already in use';
  END IF;

  -- Update the user's profile
  UPDATE auth.users SET email = LOWER(new_email) WHERE id = user_id;
  UPDATE public.users SET name = INITCAP(new_name), email = LOWER(new_email) WHERE id = user_id;

  -- Return the updated user's profile
  RETURN (SELECT row_to_json(u) FROM (SELECT name, email FROM public.users WHERE id = user_id) u);
END;
$$ LANGUAGE plpgsql SECURITY definer;

ALTER FUNCTION update_user_profile(new_name text, new_email text) OWNER TO postgres;



-- Changes a user password by first checking if the provided current password matches and if it
-- doesn't then it throws an exception. If it does match then it updates the user's password
-- with the new one.
CREATE OR REPLACE function change_user_password(current_password text, new_password text)
RETURNS VOID AS $$
DECLARE
  user_id uuid;
BEGIN
  user_id := auth.uid();

  -- Check if the passwords match
  IF EXISTS (
    SELECT 1 FROM auth.users
    WHERE id = user_id AND encrypted_password = crypt(current_password::text, auth.users.encrypted_password)
  ) THEN
    RAISE EXCEPTION 'Incorrect password';
  END IF;

  -- Then set the new password
  UPDATE auth.users SET encrypted_password = crypt(new_password, gen_salt('bf'))
  WHERE id = user_id;
END;
$$ LANGUAGE plpgsql SECURITY definer;

ALTER FUNCTION change_user_password(current_password text, new_password text) OWNER TO postgres;



-- Checks if an email is in the auth.users table, when inviting users to prevent duplicate emails
CREATE OR REPLACE FUNCTION is_email_used(email text)
RETURNS BOOLEAN AS $$
BEGIN
  RETURN EXISTS (SELECT 1 FROM auth.users as a WHERE a.email = $1);
END;
$$ LANGUAGE plpgsql SECURITY definer;

ALTER FUNCTION is_email_used(email text) OWNER TO postgres;



-- Retrieves the users from the auth.users table for the Manage Users
CREATE OR REPLACE FUNCTION get_manage_users()
RETURNS TABLE (
  id uuid,
  name text,
  email text,
  role user_role,
  confirmed_email boolean,
  created_at timestamp with time zone,
  updated_at timestamp with time zone
) AS $$
BEGIN
  RETURN QUERY
    SELECT
      u.id,
      u.name,
      u.email,
      u.role,
      (au.email_confirmed_at IS NOT NULL),
      u.created_at,
      u.updated_at
    FROM public.users u
    JOIN auth.users au ON u.id = au.id
    ORDER BY
      u.created_at ASC;
END;
$$ LANGUAGE plpgsql SECURITY definer;

ALTER FUNCTION get_manage_users() OWNER TO postgres;
